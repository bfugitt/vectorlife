<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Vector Life Console</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
    
    <!-- D3.js for the System Monitor -->
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <style>
        /* --- Vector / Phosphor Theme Styles --- */
        :root {
            /* Palette */
            --vector-color: #33ff00; 
            --vector-dim: #1a8000;
            --vector-bg: #050505;
            --vector-glow: 0 0 10px var(--vector-color), 0 0 5px var(--vector-color);
            --scanline-color: rgba(0, 0, 0, 0.5);
        }

        body {
            font-family: 'Share Tech Mono', monospace;
            background-color: var(--vector-bg);
            margin: 0;
            display: flex;
            justify-content: center;
            min-height: 100vh;
            color: var(--vector-color);
            user-select: none;
            -webkit-user-select: none;
            
            /* Allow scrolling */
            overflow-y: auto; 
            overflow-x: hidden;
            padding: 20px 10px 60px 10px;
            box-sizing: border-box;
        }

        /* Scanline Overlay */
        body::after {
            content: " ";
            display: block;
            position: fixed;
            top: 0; left: 0; bottom: 0; right: 0;
            background: linear-gradient(to bottom, var(--scanline-color) 50%, transparent 50%);
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 900;
        }

        .vector-container {
            width: 100%;
            max-width: 600px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            position: relative;
            z-index: 1;
            margin: auto;
        }

        .header {
            text-align: center;
            border: 2px solid var(--vector-color);
            padding: 10px;
            text-transform: uppercase;
            letter-spacing: 4px;
            font-size: 1.5rem;
            box-shadow: var(--vector-glow);
            text-shadow: 0 0 5px var(--vector-color);
            position: relative;
        }
        
        .header::before {
            content: ''; position: absolute; top: -6px; left: -6px; width: 10px; height: 10px;
            border-top: 2px solid var(--vector-color); border-left: 2px solid var(--vector-color);
        }
        .header::after {
            content: ''; position: absolute; bottom: -6px; right: -6px; width: 10px; height: 10px;
            border-bottom: 2px solid var(--vector-color); border-right: 2px solid var(--vector-color);
        }

        /* --- Workspace & Canvas --- */
        .workspace {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }

        .scope-container {
            position: relative;
            padding: 4px;
            border: 1px solid var(--vector-dim);
            max-width: 100%; 
        }

        .scope-corner {
            position: absolute;
            width: 15px; height: 15px;
            border-color: var(--vector-color);
            border-style: solid;
        }
        .tl { top: -2px; left: -2px; border-width: 2px 0 0 2px; }
        .tr { top: -2px; right: -2px; border-width: 2px 2px 0 0; }
        .bl { bottom: -2px; left: -2px; border-width: 0 0 2px 2px; }
        .br { bottom: -2px; right: -2px; border-width: 0 2px 2px 0; }

        canvas {
            background: rgba(0, 20, 0, 0.3);
            border: 1px solid var(--vector-dim);
            cursor: crosshair;
            image-rendering: pixelated;
            width: 100%;
            height: auto;
            max-width: 320px; 
            aspect-ratio: 1 / 1; 
            touch-action: none;
            display: block;
            box-shadow: 0 0 15px rgba(51, 255, 0, 0.2);
        }

        /* --- Controls --- */
        .controls-row {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
        }

        .btn {
            background: transparent;
            border: 1px solid var(--vector-color);
            color: var(--vector-color);
            font-family: 'Share Tech Mono', monospace;
            padding: 8px 16px;
            font-size: 1rem;
            cursor: pointer;
            text-transform: uppercase;
            position: relative;
            transition: all 0.1s;
        }

        .btn:hover:not(:disabled) {
            box-shadow: var(--vector-glow);
            background: rgba(51, 255, 0, 0.1);
        }

        .btn:active:not(:disabled) {
            transform: scale(0.95);
        }

        .btn.active {
            background: var(--vector-color);
            color: var(--vector-bg);
            box-shadow: var(--vector-glow);
            font-weight: bold;
        }
        
        .btn:disabled {
            border-color: var(--vector-dim);
            color: var(--vector-dim);
            cursor: not-allowed;
            opacity: 0.5;
            box-shadow: none;
        }
        
        .btn-danger { border-color: #ff3333; color: #ff3333; }
        .btn-danger:hover { box-shadow: 0 0 10px #ff3333; background: rgba(255, 50, 50, 0.1); }

        select {
            background: var(--vector-bg);
            border: 1px solid var(--vector-color);
            color: var(--vector-color);
            font-family: 'Share Tech Mono', monospace;
            padding: 5px;
            font-size: 1rem;
        }
        
        input[type="range"] {
            -webkit-appearance: none; background: transparent; width: 100px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 15px; width: 15px;
            border: 1px solid var(--vector-color); background: var(--vector-bg);
            cursor: pointer; margin-top: -6px;
        }
        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%; height: 2px; background: var(--vector-dim);
        }

        /* --- Graph Monitor Area --- */
        .monitor-container {
            width: 100%;
            height: 100px;
            border: 1px solid var(--vector-dim);
            position: relative;
            box-sizing: border-box;
            background: rgba(0, 10, 0, 0.5);
            margin-top: 10px;
        }
        
        .monitor-label {
            position: absolute;
            top: -10px;
            left: 10px;
            background: var(--vector-bg);
            padding: 0 5px;
            font-size: 0.8rem;
            color: var(--vector-dim);
        }
        
        .monitor-stats {
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 0.7rem;
            color: var(--vector-color);
            text-align: right;
            line-height: 1.2;
        }

        /* D3 SVG Styles */
        svg {
            width: 100%;
            height: 100%;
        }
        
        .line {
            fill: none;
            stroke: var(--vector-color);
            stroke-width: 1.5px;
            filter: drop-shadow(0 0 2px var(--vector-color));
        }
        
        .grid-line {
            stroke: var(--vector-dim);
            stroke-opacity: 0.3;
            stroke-width: 0.5px;
        }
        
        .head-dot {
            fill: var(--vector-color);
            filter: drop-shadow(0 0 4px var(--vector-color));
        }

        /* --- Modal System --- */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        .modal-overlay.hidden { display: none; }
        .modal-box {
            background: var(--vector-bg);
            border: 2px solid var(--vector-color);
            box-shadow: var(--vector-glow), inset 0 0 20px rgba(51, 255, 0, 0.2);
            padding: 20px;
            max-width: 300px;
            text-align: center;
            position: relative;
        }
        .modal-box::before {
            content: ''; position: absolute; top: -4px; left: -4px; width: 10px; height: 10px;
            border-top: 2px solid var(--vector-color); border-left: 2px solid var(--vector-color);
        }
        .modal-box::after {
            content: ''; position: absolute; bottom: -4px; right: -4px; width: 10px; height: 10px;
            border-bottom: 2px solid var(--vector-color); border-right: 2px solid var(--vector-color);
        }
        .modal-text {
            margin-bottom: 20px;
            font-size: 1.1rem;
            line-height: 1.4;
        }
        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        
        @media (max-width: 500px) {
            .btn { padding: 6px 10px; font-size: 0.9rem; }
            .header { font-size: 1.2rem; }
            .vector-container { margin-top: 10px; }
        }
    </style>
</head>
<body>

<!-- System Interrupt Modal -->
<div id="sys-modal" class="modal-overlay hidden">
    <div class="modal-box">
        <div class="modal-text" id="modal-msg">SYSTEM MESSAGE</div>
        <div class="modal-buttons">
            <button class="btn" id="modal-ok">PROCEED</button>
            <button class="btn btn-danger" id="modal-cancel">ABORT</button>
        </div>
    </div>
</div>

<div class="vector-container">
    <div class="header">VECTOR.LIFE v1.6</div>

    <div class="workspace">
        <!-- Main Grid Scope -->
        <div class="scope-container">
            <div class="scope-corner tl"></div>
            <div class="scope-corner tr"></div>
            <div class="scope-corner bl"></div>
            <div class="scope-corner br"></div>
            <canvas id="lifeCanvas" width="320" height="320"></canvas>
        </div>

        <!-- Population Monitor -->
        <div class="monitor-container">
            <span class="monitor-label">POPULATION_MONITOR</span>
            <div class="monitor-stats">
                GEN: <span id="gen-indicator">0</span><br>
                CUR: <span id="pop-indicator">0</span><br>
                MAX: <span id="max-indicator">0</span>
            </div>
            <div id="graph-area"></div>
        </div>
    </div>

    <!-- Controls Row 1: Editing & Grid -->
    <div class="controls-row">
        <button class="btn" onclick="randomizeGrid()">[RAND]</button>
        <select id="pattern-selector" onchange="loadPattern(this.value)">
            <option value="">LOAD_PATTERN</option>
            <option value="glider">GLIDER</option>
            <option value="lwss">LWSS_SHIP</option>
            <option value="pulsar">PULSAR</option>
            <option value="beacon">BEACON</option>
            <option value="block">BLOCK</option>
        </select>
        <button class="btn btn-danger" onclick="clearGridModal()">[CLEAR]</button>
    </div>
    
    <!-- Controls Row 2: Grid Res -->
    <div class="controls-row">
        <span style="font-size:0.9rem; align-self:center;">RES:</span>
        <select id="grid-res" onchange="changeResolution()">
            <option value="20">20 x 20</option>
            <option value="40" selected>40 x 40</option>
            <option value="80">80 x 80</option>
        </select>
    </div>

    <!-- Controls Row 3: Playback -->
    <div class="controls-row" style="border-top: 1px dashed var(--vector-dim); padding-top: 15px;">
        <button class="btn" id="step-btn" onclick="step()">STEP &gt;</button>
        <button class="btn active" id="play-btn" onclick="togglePlay()">RUN</button>
        <div style="display:flex; gap:5px; align-items: center;">
             <span style="font-size: 0.8rem;">SPD:</span>
             <input type="range" id="speed-range" min="1" max="60" value="10" oninput="updateSpeed()">
        </div>
    </div>

    <!-- Controls Row 4: System IO -->
    <div class="controls-row" style="border-top: 1px dashed var(--vector-dim); padding-top: 15px;">
        <!-- Disabled by default, enabled via JS when library loads -->
        <button class="btn" id="export-btn" onclick="exportLifeGIF()" style="border-style: double; border-width: 3px; width: 100%;" disabled>LOADING LIB...</button>
    </div>
</div>

<script type="module">
    // Direct named import to make sure we get the library logic
    import { GIFEncoder } from 'https://cdn.jsdelivr.net/npm/gifenc@1.0.3/dist/gifenc.esm.js';
    window.gifenc = { GIFEncoder };
    window.dispatchEvent(new Event('giflib_ready'));
</script>

<script>
    // --- Configuration ---
    let gridSize = 40;
    const canvasSize = 320;
    let pixelSize = canvasSize / gridSize;
    
    // --- State ---
    let grid = [];
    let nextGrid = [];
    let isRunning = false;
    let intervalId = null;
    let fps = 10;
    let generation = 0;
    let populationHistory = [];
    
    // Smart Paint State
    let isDrawing = false;
    let drawValue = 1;

    // --- DOM Elements ---
    const canvas = document.getElementById('lifeCanvas');
    const ctx = canvas.getContext('2d');
    const genIndicator = document.getElementById('gen-indicator');
    const popIndicator = document.getElementById('pop-indicator');
    const maxIndicator = document.getElementById('max-indicator');
    const playBtn = document.getElementById('play-btn');

    // --- D3 Graph Monitor ---
    let svg, graphScaleX, graphScaleY, lineGen;
    const maxHistory = 100;

    // --- Initialization ---
    function init() {
        createGrids();
        
        // Wait for next frame to ensure layout is ready so clientWidth > 0
        setTimeout(() => {
            initGraph(); 
            randomizeGrid(); 
            render();
            updateUI();
            
            // Check library
            if (window.gifenc) enableExport();
        }, 50);
    }
    
    function enableExport() {
        const btn = document.getElementById('export-btn');
        if (btn) {
            btn.disabled = false;
            btn.innerHTML = "&gt; EXPORT GIF SIMULATION &lt;";
        }
    }
    
    window.addEventListener('giflib_ready', enableExport);

    function createGrids() {
        grid = new Array(gridSize).fill(0).map(() => new Array(gridSize).fill(0));
        nextGrid = new Array(gridSize).fill(0).map(() => new Array(gridSize).fill(0));
    }

    // --- Modal System ---
    function showModal(msg, onConfirm = null) {
        const modal = document.getElementById('sys-modal');
        const msgEl = document.getElementById('modal-msg');
        const okBtn = document.getElementById('modal-ok');
        const cancelBtn = document.getElementById('modal-cancel');
        
        msgEl.innerText = msg;
        modal.classList.remove('hidden');
        
        okBtn.onclick = () => {
            modal.classList.add('hidden');
            if (onConfirm) onConfirm();
        };
        cancelBtn.onclick = () => {
            modal.classList.add('hidden');
        };
    }

    function clearGridModal() {
        showModal("PURGE LIFEFORMS?\nGRID WILL BE RESET.", () => {
            clearGrid();
        });
    }

    // --- Core Life Logic ---
    function countNeighbors(x, y, sourceGrid) {
        let sum = 0;
        for (let i = -1; i < 2; i++) {
            for (let j = -1; j < 2; j++) {
                let col = (x + i + gridSize) % gridSize;
                let row = (y + j + gridSize) % gridSize;
                sum += sourceGrid[row][col];
            }
        }
        sum -= sourceGrid[y][x];
        return sum;
    }

    // Updated to optionally accept a grid source/dest for simulation
    function computeNextGen(source = grid, dest = nextGrid) {
        let changed = false;
        let pop = 0;
        
        for (let y = 0; y < gridSize; y++) {
            for (let x = 0; x < gridSize; x++) {
                let state = source[y][x];
                let neighbors = countNeighbors(x, y, source);

                if (state == 0 && neighbors == 3) {
                    dest[y][x] = 1;
                    changed = true;
                } else if (state == 1 && (neighbors < 2 || neighbors > 3)) {
                    dest[y][x] = 0;
                    changed = true;
                } else {
                    dest[y][x] = state;
                }
                
                if (dest[y][x] === 1) pop++;
            }
        }
        
        return { changed, pop };
    }
    
    // Main step function for the UI loop
    function runStep() {
        const result = computeNextGen(grid, nextGrid);
        
        // Swap
        let temp = grid;
        grid = nextGrid;
        nextGrid = temp;
        
        generation++;
        updateGraphData(result.pop);
    }

    // --- Drawing Engine (Vector Style) ---
    function drawVectorRect(ctx, x, y, size, color, fill = false) {
        ctx.strokeStyle = color;
        ctx.lineWidth = 1;
        ctx.shadowBlur = 4;
        ctx.shadowColor = color;
        
        if (fill) {
            ctx.fillStyle = color;
            const gap = 1; // Small gap for grid effect
            ctx.fillRect(x + gap, y + gap, size - gap*2, size - gap*2);
            
            // White hot center
            ctx.fillStyle = "#fff";
            ctx.globalAlpha = 0.3;
            ctx.fillRect(x + size/3, y + size/3, size/3, size/3);
            ctx.globalAlpha = 1.0;
        } else {
            ctx.strokeRect(x, y, size, size);
        }
        ctx.shadowBlur = 0;
    }

    function drawGridLines(targetCtx) {
        targetCtx.strokeStyle = '#1a8000'; // Dim green
        targetCtx.lineWidth = 0.5;
        targetCtx.beginPath();
        for (let i = 0; i <= gridSize; i++) {
            targetCtx.moveTo(i * pixelSize, 0);
            targetCtx.lineTo(i * pixelSize, canvasSize);
            targetCtx.moveTo(0, i * pixelSize);
            targetCtx.lineTo(canvasSize, i * pixelSize);
        }
        targetCtx.stroke();
    }

    function render(targetCtx = ctx, sourceGrid = grid) {
        targetCtx.clearRect(0, 0, canvasSize, canvasSize);
        
        // Fill black background if rendering to export canvas
        if (targetCtx !== ctx) {
            targetCtx.fillStyle = "#000000";
            targetCtx.fillRect(0, 0, canvasSize, canvasSize);
        }
        
        drawGridLines(targetCtx);

        const color = getComputedStyle(document.documentElement).getPropertyValue('--vector-color').trim() || '#33ff00';
        
        for (let y = 0; y < gridSize; y++) {
            for (let x = 0; x < gridSize; x++) {
                if (sourceGrid[y][x] === 1) {
                    drawVectorRect(targetCtx, x * pixelSize, y * pixelSize, pixelSize, color, true);
                }
            }
        }
        
        if (targetCtx === ctx) updateUI();
    }

    function updateUI() {
        genIndicator.innerText = generation;
        // Pop updated in updateGraphData for sync
    }

    // --- Interactive "Smart Paint" ---
    function getGridCoords(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvasSize / rect.width;
        const scaleY = canvasSize / rect.height;
        
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        
        const x = Math.floor(((clientX - rect.left) * scaleX) / pixelSize);
        const y = Math.floor(((clientY - rect.top) * scaleY) / pixelSize);
        return { x, y };
    }

    function handleStart(e) {
        if (e.cancelable) e.preventDefault();
        isDrawing = true;
        const { x, y } = getGridCoords(e);
        if (x >= 0 && x < gridSize && y >= 0 && y < gridSize) {
            drawValue = grid[y][x] === 1 ? 0 : 1;
            paint(x, y);
        }
    }

    function handleMove(e) {
        if (!isDrawing) return;
        if (e.cancelable) e.preventDefault();
        const { x, y } = getGridCoords(e);
        if (x >= 0 && x < gridSize && y >= 0 && y < gridSize) {
            paint(x, y);
        }
    }

    function handleEnd() {
        isDrawing = false;
    }

    function paint(x, y) {
        if (grid[y][x] !== drawValue) {
            grid[y][x] = drawValue;
            render();
        }
    }

    canvas.addEventListener('mousedown', handleStart);
    canvas.addEventListener('mousemove', handleMove);
    window.addEventListener('mouseup', handleEnd);
    canvas.addEventListener('touchstart', handleStart, {passive: false});
    canvas.addEventListener('touchmove', handleMove, {passive: false});
    canvas.addEventListener('touchend', handleEnd);


    // --- Control Logic ---
    function togglePlay() {
        if (isRunning) stopSimulation();
        else startSimulation();
    }

    function startSimulation() {
        if (isRunning) return;
        isRunning = true;
        playBtn.innerText = "HALT";
        playBtn.classList.add('active'); // Ensure glow
        document.getElementById('step-btn').disabled = true;
        
        intervalId = setInterval(() => {
            runStep();
            render();
        }, 1000 / fps);
    }

    function stopSimulation() {
        if (!isRunning) return;
        isRunning = false;
        clearInterval(intervalId);
        playBtn.innerText = "RUN";
        playBtn.classList.remove('active'); 
        document.getElementById('step-btn').disabled = false;
    }

    function step() {
        if (isRunning) stopSimulation();
        runStep();
        render();
    }

    function clearGrid() {
        stopSimulation();
        grid = new Array(gridSize).fill(0).map(() => new Array(gridSize).fill(0));
        generation = 0;
        populationHistory = [];
        resetGraph();
        render();
    }

    function randomizeGrid() {
        stopSimulation();
        generation = 0;
        populationHistory = [];
        
        if (!graphScaleY) initGraph();
        
        let pop = 0;
        for (let y = 0; y < gridSize; y++) {
            for (let x = 0; x < gridSize; x++) {
                const alive = Math.random() > 0.7 ? 1 : 0;
                grid[y][x] = alive;
                if(alive) pop++;
            }
        }
        
        updateGraphData(pop);
        render();
    }
    
    function changeResolution() {
        showModal("CHANGE RESOLUTION?\nGRID WILL BE CLEARED.", () => {
            const select = document.getElementById('grid-res');
            gridSize = parseInt(select.value);
            pixelSize = canvasSize / gridSize;
            createGrids();
            clearGrid(); 
            randomizeGrid(); 
        });
    }

    function updateSpeed() {
        const slider = document.getElementById('speed-range');
        fps = parseInt(slider.value);
        if (isRunning) {
            stopSimulation();
            startSimulation();
        }
    }
    
    // --- Patterns ---
    function loadPattern(type) {
        if (!type) return;
        stopSimulation();
        
        const padding = 5;
        const maxX = Math.max(0, gridSize - padding);
        const cx = Math.floor(Math.random() * (maxX - padding)) + padding;
        const cy = Math.floor(Math.random() * (maxX - padding)) + padding;

        const set = (r, c) => {
            if(r >=0 && r < gridSize && c >=0 && c < gridSize) {
                grid[r][c] = 1;
            }
        };

        if (type === 'glider') {
            set(cy, cx+1);
            set(cy+1, cx+2);
            set(cy+2, cx); set(cy+2, cx+1); set(cy+2, cx+2);
        } else if (type === 'block') {
            set(cy, cx); set(cy, cx+1); 
            set(cy+1, cx); set(cy+1, cx+1);
        } else if (type === 'beacon') {
            set(cy, cx); set(cy, cx+1); set(cy+1, cx);
            set(cy+2, cx+3); set(cy+3, cx+2); set(cy+3, cx+3);
        } else if (type === 'pulsar') {
             const p = [2, 3, 4];
             for (let i of p) {
                 set(cy-1, cx-i); set(cy-1, cx+i);
                 set(cy+1, cx-i); set(cy+1, cx+i);
                 set(cy-6, cx-i); set(cy-6, cx+i);
                 set(cy+6, cx-i); set(cy+6, cx+i);
             }
             for (let i of p) {
                 set(cy-i, cx-1); set(cy-i, cx+1);
                 set(cy+i, cx-1); set(cy+i, cx+1);
                 set(cy-i, cx-6); set(cy-i, cx+6);
                 set(cy+i, cx-6); set(cy+i, cx+6);
             }
        } else if (type === 'lwss') {
            set(cy, cx+1); set(cy, cx+4);
            set(cy+1, cx);
            set(cy+2, cx); set(cy+2, cx+4);
            set(cy+3, cx); set(cy+3, cx+1); set(cy+3, cx+2); set(cy+3, cx+3);
        }
        
        let totalPop = 0;
        for (let row of grid) for (let cell of row) if (cell) totalPop++;
        
        updateGraphData(totalPop);
        document.getElementById('pattern-selector').value = ""; 
        render();
    }

    // --- HEX to RGB Helper ---
    function hexToRgb(hex) {
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : { r: 51, g: 255, b: 0 };
    }

    function getTimestampFilename(ext) {
        const now = new Date();
        return `LIFE_${now.getTime()}.${ext}`;
    }

    // --- EXPORT GIF LOGIC ---
    function exportLifeGIF() {
        if (!window.gifenc || !window.gifenc.GIFEncoder) { 
            showModal("LIBRARY ERROR\nPLEASE RELOAD.");
            return; 
        }
        
        // Pause execution so we get a clean snapshot
        const wasRunning = isRunning;
        stopSimulation();

        const { GIFEncoder } = window.gifenc;
        const btn = document.getElementById('export-btn');
        const originalText = btn.innerText;
        btn.innerText = "SIMULATING...";
        btn.disabled = true;

        setTimeout(() => {
            try {
                const gif = new GIFEncoder();
                const canvasW = canvas.width;
                const canvasH = canvas.height;
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = canvasW;
                tempCanvas.height = canvasH;
                const tCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
                
                // Color Prep
                let colorHex = getComputedStyle(document.documentElement).getPropertyValue('--vector-color').trim();
                if (!colorHex) colorHex = '#33ff00';
                const baseColor = hexToRgb(colorHex);

                // Palette Gen (Black -> Color Gradient)
                const palette = [[5, 5, 5]]; 
                for (let i = 1; i < 256; i++) {
                    const ratio = i / 255;
                    let r = Math.floor(5 + (baseColor.r - 5) * ratio);
                    let g = Math.floor(5 + (baseColor.g - 5) * ratio);
                    let b = Math.floor(5 + (baseColor.b - 5) * ratio);
                    palette.push([r, g, b]);
                }

                // Setup Simulation Clone
                // We use Deep Copy so we don't mess up the actual game board
                let simGrid = JSON.parse(JSON.stringify(grid));
                let simNextGrid = new Array(gridSize).fill(0).map(() => new Array(gridSize).fill(0));
                
                // Capture Loop
                const maxFrames = 120; // 120 frames @ 20fps = 6 seconds
                let lastGridStr = "";

                for (let f = 0; f < maxFrames; f++) {
                    // 1. Render Current State to Temp Canvas
                    render(tCtx, simGrid);
                    
                    // 2. Map Pixels to Palette
                    const imageData = tCtx.getImageData(0, 0, canvasW, canvasH).data;
                    const index = new Uint8Array(canvasW * canvasH);
                    
                    for (let i = 0; i < imageData.length; i += 4) {
                        const r = imageData[i];
                        const g = imageData[i + 1];
                        const b = imageData[i + 2];
                        const a = imageData[i + 3];
                        if (a < 50) { index[i / 4] = 0; continue; }
                        let brightness = Math.max(r, g, b);
                        if (brightness < 10) index[i / 4] = 0;
                        else index[i / 4] = brightness; 
                    }
                    
                    // 3. Write Frame
                    gif.writeFrame(index, canvasW, canvasH, { 
                        palette: palette, 
                        delay: 100 // 100ms = 10fps for slower, clearer viewing
                    });

                    // 4. Advance Simulation Step
                    // Check stability (simple static check)
                    const currentStr = JSON.stringify(simGrid);
                    if (currentStr === lastGridStr) {
                        console.log("Stabilized at frame " + f);
                        break; // Stop recording if static
                    }
                    lastGridStr = currentStr;

                    // Compute next step on the clone
                    computeNextGen(simGrid, simNextGrid);
                    // Swap
                    let temp = simGrid;
                    simGrid = simNextGrid;
                    simNextGrid = temp;
                }
                
                gif.finish();
                
                // Download
                const blob = new Blob([gif.bytes()], { type: 'image/gif' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = getTimestampFilename('gif');
                a.click();
                
            } catch (e) {
                console.error(e);
                showModal("ERROR:\n" + e.message);
            } finally {
                btn.innerText = originalText;
                btn.disabled = false;
                // Resume if it was running
                if (wasRunning) startSimulation();
            }
        }, 50);
    }

    function saveProject() {
       // Placeholder if you want save functionality later
       // Just alerting for now since JSON save wasn't requested for Life
       const data = { gridSize, grid };
       const blob = new Blob([JSON.stringify(data)], {type: "application/json"});
       const url = URL.createObjectURL(blob);
       const a = document.createElement('a');
       a.href = url;
       a.download = getTimestampFilename('json');
       a.click();
    }
    
    function loadProject(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (evt) => {
            try {
                const data = JSON.parse(evt.target.result);
                stopSimulation();
                if(data.gridSize) {
                    gridSize = data.gridSize;
                    pixelSize = canvasSize / gridSize;
                    // update dropdown
                    document.getElementById('grid-res').value = gridSize;
                }
                if(data.grid) {
                    grid = data.grid;
                    nextGrid = new Array(gridSize).fill(0).map(() => new Array(gridSize).fill(0));
                }
                generation = 0;
                populationHistory = [];
                initGraph(); // Reset graph
                // Calculate pop
                let pop = 0;
                for (let r of grid) for (let c of r) if (c) pop++;
                updateGraphData(pop);
                render();
            } catch(err) { showModal("DATA ERROR"); }
        };
        reader.readAsText(file);
        e.target.value = '';
    }

    // --- D3 Graph Monitor ---
    
    function initGraph() {
        const container = document.getElementById('graph-area');
        container.innerHTML = '';
        
        // Ensure width is valid even if hidden
        const width = Math.max(container.clientWidth, 300) - 10;
        const height = Math.max(container.clientHeight, 100) - 10;
        const margin = {top: 5, left: 5};

        svg = d3.select("#graph-area")
            .append("svg")
            .attr("width", "100%")
            .attr("height", "100%")
            .attr("viewBox", `0 0 ${width + 10} ${height + 10}`)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        // Draw background grid lines
        for(let i=0; i<=10; i++) {
            svg.append("line")
               .attr("class", "grid-line")
               .attr("x1", (width/10)*i).attr("y1", 0)
               .attr("x2", (width/10)*i).attr("y2", height);
            
            svg.append("line")
               .attr("class", "grid-line")
               .attr("x1", 0).attr("y1", (height/10)*i)
               .attr("x2", width).attr("y2", (height/10)*i);
        }

        // Scales
        graphScaleX = d3.scaleLinear().domain([0, maxHistory]).range([0, width]);
        graphScaleY = d3.scaleLinear().domain([0, gridSize*gridSize]).range([height, 0]);

        // Line Generator
        lineGen = d3.line()
            .x((d, i) => graphScaleX(i))
            .y((d) => graphScaleY(d))
            .curve(d3.curveMonotoneX);

        // Path
        svg.append("path")
            .datum(populationHistory)
            .attr("class", "line")
            .attr("d", lineGen);
    }
    
    function resetGraph() {
        populationHistory = [];
        updateGraphData(0);
    }

    function updateGraphData(pop) {
        populationHistory.push(pop);
        if (populationHistory.length > maxHistory) {
            populationHistory.shift();
        }

        // Update domains
        const maxPop = d3.max(populationHistory) || 10;
        if (maxIndicator) maxIndicator.innerText = maxPop;
        
        if(graphScaleY) {
            graphScaleY.domain([0, maxPop * 1.2]); 

            svg.select(".line")
                .datum(populationHistory)
                .attr("d", lineGen);
            
            // Add or Update Head Dot
            const lastIndex = populationHistory.length - 1;
            svg.selectAll(".head-dot").remove(); 
            
            svg.append("circle")
               .attr("class", "head-dot")
               .attr("cx", graphScaleX(lastIndex))
               .attr("cy", graphScaleY(pop))
               .attr("r", 3);
        }
            
        popIndicator.innerText = pop;
    }
    
    // Handle Window Resize for Graph
    window.addEventListener('resize', () => {
        initGraph(); 
    });

    // --- Start ---
    init();

</script>
</body>
</html>
