<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Vector Life Console</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
    
    <!-- D3.js for the System Monitor -->
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <style>
        /* --- Vector / Phosphor Theme Styles --- */
        :root {
            /* Palette */
            --vector-color: #33ff00; 
            --vector-dim: #1a8000;
            --vector-bg: #050505;
            --vector-glow: 0 0 10px var(--vector-color), 0 0 5px var(--vector-color);
            --scanline-color: rgba(0, 0, 0, 0.5);
        }

        body {
            font-family: 'Share Tech Mono', monospace;
            background-color: var(--vector-bg);
            margin: 0;
            display: flex;
            justify-content: center;
            min-height: 100vh;
            color: var(--vector-color);
            user-select: none;
            -webkit-user-select: none;
            
            /* Allow scrolling */
            overflow-y: auto; 
            overflow-x: hidden;
            padding: 20px 10px 60px 10px;
            box-sizing: border-box;
        }

        /* Scanline Overlay */
        body::after {
            content: " ";
            display: block;
            position: fixed;
            top: 0; left: 0; bottom: 0; right: 0;
            background: linear-gradient(to bottom, var(--scanline-color) 50%, transparent 50%);
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 900;
        }

        .vector-container {
            width: 100%;
            max-width: 600px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            position: relative;
            z-index: 1;
            margin: auto;
        }

        .header {
            text-align: center;
            border: 2px solid var(--vector-color);
            padding: 10px;
            text-transform: uppercase;
            letter-spacing: 4px;
            font-size: 1.5rem;
            box-shadow: var(--vector-glow);
            text-shadow: 0 0 5px var(--vector-color);
            position: relative;
        }
        
        .header::before {
            content: ''; position: absolute; top: -6px; left: -6px; width: 10px; height: 10px;
            border-top: 2px solid var(--vector-color); border-left: 2px solid var(--vector-color);
        }
        .header::after {
            content: ''; position: absolute; bottom: -6px; right: -6px; width: 10px; height: 10px;
            border-bottom: 2px solid var(--vector-color); border-right: 2px solid var(--vector-color);
        }

        /* --- Workspace & Canvas --- */
        .workspace {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }

        .scope-container {
            position: relative;
            padding: 4px;
            border: 1px solid var(--vector-dim);
            max-width: 100%; 
        }

        .scope-corner {
            position: absolute;
            width: 15px; height: 15px;
            border-color: var(--vector-color);
            border-style: solid;
        }
        .tl { top: -2px; left: -2px; border-width: 2px 0 0 2px; }
        .tr { top: -2px; right: -2px; border-width: 2px 2px 0 0; }
        .bl { bottom: -2px; left: -2px; border-width: 0 0 2px 2px; }
        .br { bottom: -2px; right: -2px; border-width: 0 2px 2px 0; }

        canvas {
            background: rgba(0, 20, 0, 0.3);
            border: 1px solid var(--vector-dim);
            cursor: crosshair;
            image-rendering: pixelated;
            width: 100%;
            height: auto;
            max-width: 320px; 
            aspect-ratio: 1 / 1; 
            touch-action: none;
            display: block;
            box-shadow: 0 0 15px rgba(51, 255, 0, 0.2);
        }

        /* --- Controls --- */
        .controls-row {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
        }

        .btn {
            background: transparent;
            border: 1px solid var(--vector-color);
            color: var(--vector-color);
            font-family: 'Share Tech Mono', monospace;
            padding: 8px 16px;
            font-size: 1rem;
            cursor: pointer;
            text-transform: uppercase;
            position: relative;
            transition: all 0.1s;
        }

        .btn:hover:not(:disabled) {
            box-shadow: var(--vector-glow);
            background: rgba(51, 255, 0, 0.1);
        }

        .btn:active:not(:disabled) {
            transform: scale(0.95);
        }

        .btn.active {
            background: var(--vector-color);
            color: var(--vector-bg);
            box-shadow: var(--vector-glow);
            font-weight: bold;
        }
        
        .btn:disabled {
            border-color: var(--vector-dim);
            color: var(--vector-dim);
            cursor: not-allowed;
            opacity: 0.5;
            box-shadow: none;
        }
        
        .btn-danger { border-color: #ff3333; color: #ff3333; }
        .btn-danger:hover { box-shadow: 0 0 10px #ff3333; background: rgba(255, 50, 50, 0.1); }

        select {
            background: var(--vector-bg);
            border: 1px solid var(--vector-color);
            color: var(--vector-color);
            font-family: 'Share Tech Mono', monospace;
            padding: 5px;
            font-size: 1rem;
        }
        
        input[type="range"] {
            -webkit-appearance: none; background: transparent; width: 100px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 15px; width: 15px;
            border: 1px solid var(--vector-color); background: var(--vector-bg);
            cursor: pointer; margin-top: -6px;
        }
        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%; height: 2px; background: var(--vector-dim);
        }

        /* --- Graph Monitor Area --- */
        .monitor-container {
            width: 100%;
            height: 100px;
            border: 1px solid var(--vector-dim);
            position: relative;
            box-sizing: border-box;
            background: rgba(0, 10, 0, 0.5);
            margin-top: 10px;
        }
        
        .monitor-label {
            position: absolute;
            top: -10px;
            left: 10px;
            background: var(--vector-bg);
            padding: 0 5px;
            font-size: 0.8rem;
            color: var(--vector-dim);
        }
        
        .monitor-stats {
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 0.7rem;
            color: var(--vector-color);
            text-align: right;
            line-height: 1.2;
        }

        /* D3 SVG Styles */
        svg {
            width: 100%;
            height: 100%;
        }
        
        .line {
            fill: none;
            stroke: var(--vector-color);
            stroke-width: 1.5px;
            filter: drop-shadow(0 0 2px var(--vector-color));
        }
        
        .grid-line {
            stroke: var(--vector-dim);
            stroke-opacity: 0.3;
            stroke-width: 0.5px;
        }
        
        .head-dot {
            fill: var(--vector-color);
            filter: drop-shadow(0 0 4px var(--vector-color));
        }

        /* --- Modal System --- */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        .modal-overlay.hidden { display: none; }
        .modal-box {
            background: var(--vector-bg);
            border: 2px solid var(--vector-color);
            box-shadow: var(--vector-glow), inset 0 0 20px rgba(51, 255, 0, 0.2);
            padding: 20px;
            max-width: 300px;
            text-align: center;
            position: relative;
        }
        .modal-box::before {
            content: ''; position: absolute; top: -4px; left: -4px; width: 10px; height: 10px;
            border-top: 2px solid var(--vector-color); border-left: 2px solid var(--vector-color);
        }
        .modal-box::after {
            content: ''; position: absolute; bottom: -4px; right: -4px; width: 10px; height: 10px;
            border-bottom: 2px solid var(--vector-color); border-right: 2px solid var(--vector-color);
        }
        .modal-text {
            margin-bottom: 20px;
            font-size: 1.1rem;
            line-height: 1.4;
        }
        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        
        @media (max-width: 500px) {
            .btn { padding: 6px 10px; font-size: 0.9rem; }
            .header { font-size: 1.2rem; }
            .vector-container { margin-top: 10px; }
        }
    </style>
</head>
<body>

<!-- System Interrupt Modal -->
<div id="sys-modal" class="modal-overlay hidden">
    <div class="modal-box">
        <div class="modal-text" id="modal-msg">SYSTEM MESSAGE</div>
        <div class="modal-buttons">
            <button class="btn" id="modal-ok">PROCEED</button>
            <button class="btn btn-danger" id="modal-cancel">ABORT</button>
        </div>
    </div>
</div>

<div class="vector-container">
    <div class="header">VECTOR.LIFE v1.5</div>

    <div class="workspace">
        <!-- Main Grid Scope -->
        <div class="scope-container">
            <div class="scope-corner tl"></div>
            <div class="scope-corner tr"></div>
            <div class="scope-corner bl"></div>
            <div class="scope-corner br"></div>
            <canvas id="lifeCanvas" width="320" height="320"></canvas>
        </div>

        <!-- Population Monitor -->
        <div class="monitor-container">
            <span class="monitor-label">POPULATION_MONITOR</span>
            <div class="monitor-stats">
                GEN: <span id="gen-indicator">0</span><br>
                CUR: <span id="pop-indicator">0</span><br>
                MAX: <span id="max-indicator">0</span>
            </div>
            <div id="graph-area"></div>
        </div>
    </div>

    <!-- Controls Row 1: Editing & Grid -->
    <div class="controls-row">
        <button class="btn" onclick="randomizeGrid()">[RAND]</button>
        <select id="pattern-selector" onchange="loadPattern(this.value)">
            <option value="">LOAD_PATTERN</option>
            <option value="glider">GLIDER</option>
            <option value="lwss">LWSS_SHIP</option>
            <option value="pulsar">PULSAR</option>
            <option value="beacon">BEACON</option>
            <option value="block">BLOCK</option>
        </select>
        <button class="btn btn-danger" onclick="clearGridModal()">[CLEAR]</button>
    </div>
    
    <!-- Controls Row 2: Grid Res -->
    <div class="controls-row">
        <span style="font-size:0.9rem; align-self:center;">RES:</span>
        <select id="grid-res" onchange="changeResolution()">
            <option value="20">20 x 20</option>
            <option value="40" selected>40 x 40</option>
            <option value="80">80 x 80</option>
        </select>
    </div>

    <!-- Controls Row 3: Playback -->
    <div class="controls-row" style="border-top: 1px dashed var(--vector-dim); padding-top: 15px;">
        <button class="btn" id="step-btn" onclick="step()">STEP &gt;</button>
        <button class="btn active" id="play-btn" onclick="togglePlay()">RUN</button>
        <div style="display:flex; gap:5px; align-items: center;">
             <span style="font-size: 0.8rem;">SPD:</span>
             <input type="range" id="speed-range" min="1" max="60" value="10" oninput="updateSpeed()">
        </div>
    </div>
</div>

<script>
    // --- Configuration ---
    let gridSize = 40;
    const canvasSize = 320;
    let pixelSize = canvasSize / gridSize;
    
    // --- State ---
    let grid = [];
    let nextGrid = [];
    let isRunning = false;
    let intervalId = null;
    let fps = 10;
    let generation = 0;
    let populationHistory = [];
    
    // Smart Paint State
    let isDrawing = false;
    let drawValue = 1;

    // --- DOM Elements ---
    const canvas = document.getElementById('lifeCanvas');
    const ctx = canvas.getContext('2d');
    const genIndicator = document.getElementById('gen-indicator');
    const popIndicator = document.getElementById('pop-indicator');
    const maxIndicator = document.getElementById('max-indicator');
    const playBtn = document.getElementById('play-btn');

    // --- D3 Graph Monitor ---
    let svg, graphScaleX, graphScaleY, lineGen;
    const maxHistory = 100;

    // --- Initialization ---
    function init() {
        createGrids();
        
        // Wait for next frame to ensure layout is ready so clientWidth > 0
        setTimeout(() => {
            initGraph(); 
            randomizeGrid(); 
            render();
            updateUI();
        }, 50);
    }

    function createGrids() {
        grid = new Array(gridSize).fill(0).map(() => new Array(gridSize).fill(0));
        nextGrid = new Array(gridSize).fill(0).map(() => new Array(gridSize).fill(0));
    }

    // --- Modal System ---
    function showModal(msg, onConfirm = null) {
        const modal = document.getElementById('sys-modal');
        const msgEl = document.getElementById('modal-msg');
        const okBtn = document.getElementById('modal-ok');
        const cancelBtn = document.getElementById('modal-cancel');
        
        msgEl.innerText = msg;
        modal.classList.remove('hidden');
        
        okBtn.onclick = () => {
            modal.classList.add('hidden');
            if (onConfirm) onConfirm();
        };
        cancelBtn.onclick = () => {
            modal.classList.add('hidden');
        };
    }

    function clearGridModal() {
        showModal("PURGE LIFEFORMS?\nGRID WILL BE RESET.", () => {
            clearGrid();
        });
    }

    // --- Core Life Logic ---
    function countNeighbors(x, y) {
        let sum = 0;
        for (let i = -1; i < 2; i++) {
            for (let j = -1; j < 2; j++) {
                let col = (x + i + gridSize) % gridSize;
                let row = (y + j + gridSize) % gridSize;
                sum += grid[row][col];
            }
        }
        sum -= grid[y][x];
        return sum;
    }

    function computeNextGen() {
        let changed = false;
        let pop = 0;
        
        for (let y = 0; y < gridSize; y++) {
            for (let x = 0; x < gridSize; x++) {
                let state = grid[y][x];
                let neighbors = countNeighbors(x, y);

                if (state == 0 && neighbors == 3) {
                    nextGrid[y][x] = 1;
                    changed = true;
                } else if (state == 1 && (neighbors < 2 || neighbors > 3)) {
                    nextGrid[y][x] = 0;
                    changed = true;
                } else {
                    nextGrid[y][x] = state;
                }
                
                if (nextGrid[y][x] === 1) pop++;
            }
        }

        // Swap grids
        let temp = grid;
        grid = nextGrid;
        nextGrid = temp;
        
        generation++;
        updateGraphData(pop);
        return changed;
    }

    // --- Drawing Engine (Vector Style) ---
    function drawVectorRect(ctx, x, y, size, color, fill = false) {
        ctx.strokeStyle = color;
        ctx.lineWidth = 1;
        ctx.shadowBlur = 4;
        ctx.shadowColor = color;
        
        if (fill) {
            ctx.fillStyle = color;
            const gap = 1; // Small gap for grid effect
            ctx.fillRect(x + gap, y + gap, size - gap*2, size - gap*2);
            
            // White hot center
            ctx.fillStyle = "#fff";
            ctx.globalAlpha = 0.3;
            ctx.fillRect(x + size/3, y + size/3, size/3, size/3);
            ctx.globalAlpha = 1.0;
        } else {
            ctx.strokeRect(x, y, size, size);
        }
        ctx.shadowBlur = 0;
    }

    function drawGridLines() {
        ctx.strokeStyle = '#1a8000'; // Dim green
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        for (let i = 0; i <= gridSize; i++) {
            ctx.moveTo(i * pixelSize, 0);
            ctx.lineTo(i * pixelSize, canvasSize);
            ctx.moveTo(0, i * pixelSize);
            ctx.lineTo(canvasSize, i * pixelSize);
        }
        ctx.stroke();
    }

    function render() {
        ctx.clearRect(0, 0, canvasSize, canvasSize);
        drawGridLines();

        const color = getComputedStyle(document.documentElement).getPropertyValue('--vector-color').trim();
        
        for (let y = 0; y < gridSize; y++) {
            for (let x = 0; x < gridSize; x++) {
                if (grid[y][x] === 1) {
                    drawVectorRect(ctx, x * pixelSize, y * pixelSize, pixelSize, color, true);
                }
            }
        }
        updateUI();
    }

    function updateUI() {
        genIndicator.innerText = generation;
        // Pop updated in updateGraphData for sync
    }

    // --- Interactive "Smart Paint" ---
    function getGridCoords(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvasSize / rect.width;
        const scaleY = canvasSize / rect.height;
        
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        
        const x = Math.floor(((clientX - rect.left) * scaleX) / pixelSize);
        const y = Math.floor(((clientY - rect.top) * scaleY) / pixelSize);
        return { x, y };
    }

    function handleStart(e) {
        if (e.cancelable) e.preventDefault();
        isDrawing = true;
        const { x, y } = getGridCoords(e);
        if (x >= 0 && x < gridSize && y >= 0 && y < gridSize) {
            drawValue = grid[y][x] === 1 ? 0 : 1;
            paint(x, y);
        }
    }

    function handleMove(e) {
        if (!isDrawing) return;
        if (e.cancelable) e.preventDefault();
        const { x, y } = getGridCoords(e);
        if (x >= 0 && x < gridSize && y >= 0 && y < gridSize) {
            paint(x, y);
        }
    }

    function handleEnd() {
        isDrawing = false;
    }

    function paint(x, y) {
        if (grid[y][x] !== drawValue) {
            grid[y][x] = drawValue;
            render();
        }
    }

    canvas.addEventListener('mousedown', handleStart);
    canvas.addEventListener('mousemove', handleMove);
    window.addEventListener('mouseup', handleEnd);
    canvas.addEventListener('touchstart', handleStart, {passive: false});
    canvas.addEventListener('touchmove', handleMove, {passive: false});
    canvas.addEventListener('touchend', handleEnd);


    // --- Control Logic ---
    function togglePlay() {
        if (isRunning) stopSimulation();
        else startSimulation();
    }

    function startSimulation() {
        if (isRunning) return;
        isRunning = true;
        playBtn.innerText = "HALT";
        playBtn.classList.add('active'); // Ensure glow
        document.getElementById('step-btn').disabled = true;
        
        intervalId = setInterval(() => {
            computeNextGen();
            render();
        }, 1000 / fps);
    }

    function stopSimulation() {
        if (!isRunning) return;
        isRunning = false;
        clearInterval(intervalId);
        playBtn.innerText = "RUN";
        playBtn.classList.remove('active'); 
        document.getElementById('step-btn').disabled = false;
    }

    function step() {
        if (isRunning) stopSimulation();
        computeNextGen();
        render();
    }

    function clearGrid() {
        stopSimulation();
        grid = new Array(gridSize).fill(0).map(() => new Array(gridSize).fill(0));
        generation = 0;
        populationHistory = [];
        resetGraph();
        render();
    }

    function randomizeGrid() {
        stopSimulation();
        generation = 0;
        populationHistory = [];
        
        // Ensure graph variables are initialized just in case (though init fixes this)
        if (!graphScaleY) initGraph();
        
        let pop = 0;
        for (let y = 0; y < gridSize; y++) {
            for (let x = 0; x < gridSize; x++) {
                const alive = Math.random() > 0.7 ? 1 : 0;
                grid[y][x] = alive;
                if(alive) pop++;
            }
        }
        
        updateGraphData(pop);
        render();
    }
    
    function changeResolution() {
        showModal("CHANGE RESOLUTION?\nGRID WILL BE CLEARED.", () => {
            const select = document.getElementById('grid-res');
            gridSize = parseInt(select.value);
            pixelSize = canvasSize / gridSize;
            createGrids();
            clearGrid(); 
            randomizeGrid(); 
        });
    }

    function updateSpeed() {
        const slider = document.getElementById('speed-range');
        fps = parseInt(slider.value);
        if (isRunning) {
            stopSimulation();
            startSimulation();
        }
    }
    
    // --- Patterns ---
    function loadPattern(type) {
        if (!type) return;
        
        stopSimulation();
        
        // Add pattern to CURRENT grid (Additive logic)
        
        const padding = 5;
        const maxX = Math.max(0, gridSize - padding);
        const cx = Math.floor(Math.random() * (maxX - padding)) + padding;
        const cy = Math.floor(Math.random() * (maxX - padding)) + padding;

        const set = (r, c) => {
            if(r >=0 && r < gridSize && c >=0 && c < gridSize) {
                grid[r][c] = 1;
            }
        };

        if (type === 'glider') {
            // Standard Glider moving SE
            // . O .
            // . . O
            // O O O
            set(cy, cx+1);
            set(cy+1, cx+2);
            set(cy+2, cx); set(cy+2, cx+1); set(cy+2, cx+2);
        } else if (type === 'block') {
            // 2x2 Block
            set(cy, cx); set(cy, cx+1); 
            set(cy+1, cx); set(cy+1, cx+1);
        } else if (type === 'beacon') {
            // Beacon (Period 2)
            // O O . .
            // O O . .
            // . . O O
            // . . O O
            set(cy, cx); set(cy, cx+1);
            set(cy+1, cx); set(cy+1, cx+1);
            set(cy+2, cx+2); set(cy+2, cx+3);
            set(cy+3, cx+2); set(cy+3, cx+3);
        } else if (type === 'pulsar') {
             // Pulsar (Period 3) - Uses center offsets
             // Requires about 13x13 space
             const p = [2, 3, 4];
             // Vertical bars
             for (let i of p) {
                 set(cy-1, cx-i); set(cy-1, cx+i);
                 set(cy+1, cx-i); set(cy+1, cx+i);
                 set(cy-6, cx-i); set(cy-6, cx+i);
                 set(cy+6, cx-i); set(cy+6, cx+i);
             }
             // Horizontal bars
             for (let i of p) {
                 set(cy-i, cx-1); set(cy-i, cx+1);
                 set(cy+i, cx-1); set(cy+i, cx+1);
                 set(cy-i, cx-6); set(cy-i, cx+6);
                 set(cy+i, cx-6); set(cy+i, cx+6);
             }
        } else if (type === 'lwss') {
            // LWSS moving Right
            // . O . . O
            // O . . . .
            // O . . . O
            // O O O O .
            set(cy, cx+1); set(cy, cx+4);
            set(cy+1, cx);
            set(cy+2, cx); set(cy+2, cx+4);
            set(cy+3, cx); set(cy+3, cx+1); set(cy+3, cx+2); set(cy+3, cx+3);
        }
        
        let totalPop = 0;
        for (let row of grid) for (let cell of row) if (cell) totalPop++;
        
        updateGraphData(totalPop);
        document.getElementById('pattern-selector').value = ""; 
        render();
    }

    // --- D3 Graph Monitor ---
    
    function initGraph() {
        const container = document.getElementById('graph-area');
        container.innerHTML = '';
        
        // Ensure width is valid even if hidden
        const width = Math.max(container.clientWidth, 300) - 10;
        const height = Math.max(container.clientHeight, 100) - 10;
        const margin = {top: 5, left: 5};

        svg = d3.select("#graph-area")
            .append("svg")
            .attr("width", "100%")
            .attr("height", "100%")
            .attr("viewBox", `0 0 ${width + 10} ${height + 10}`)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        // Draw background grid lines
        for(let i=0; i<=10; i++) {
            svg.append("line")
               .attr("class", "grid-line")
               .attr("x1", (width/10)*i).attr("y1", 0)
               .attr("x2", (width/10)*i).attr("y2", height);
            
            svg.append("line")
               .attr("class", "grid-line")
               .attr("x1", 0).attr("y1", (height/10)*i)
               .attr("x2", width).attr("y2", (height/10)*i);
        }

        // Scales
        graphScaleX = d3.scaleLinear().domain([0, maxHistory]).range([0, width]);
        graphScaleY = d3.scaleLinear().domain([0, gridSize*gridSize]).range([height, 0]);

        // Line Generator
        lineGen = d3.line()
            .x((d, i) => graphScaleX(i))
            .y((d) => graphScaleY(d))
            .curve(d3.curveMonotoneX);

        // Path
        svg.append("path")
            .datum(populationHistory)
            .attr("class", "line")
            .attr("d", lineGen);
    }
    
    function resetGraph() {
        populationHistory = [];
        updateGraphData(0);
    }

    function updateGraphData(pop) {
        populationHistory.push(pop);
        if (populationHistory.length > maxHistory) {
            populationHistory.shift();
        }

        // Update domains
        // Ensure we scale to see the top clearly
        const maxPop = d3.max(populationHistory) || 10;
        // Track the highest visible pop
        if (maxIndicator) maxIndicator.innerText = maxPop;
        
        if(graphScaleY) {
            graphScaleY.domain([0, maxPop * 1.2]); 

            svg.select(".line")
                .datum(populationHistory)
                .attr("d", lineGen);
            
            // Add or Update Head Dot
            const lastIndex = populationHistory.length - 1;
            svg.selectAll(".head-dot").remove(); 
            
            svg.append("circle")
               .attr("class", "head-dot")
               .attr("cx", graphScaleX(lastIndex))
               .attr("cy", graphScaleY(pop))
               .attr("r", 3);
        }
            
        popIndicator.innerText = pop;
    }
    
    // Handle Window Resize for Graph
    window.addEventListener('resize', () => {
        initGraph(); 
    });

    // --- Start ---
    init();

</script>
</body>
</html>
